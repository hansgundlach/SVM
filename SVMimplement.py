# -*- coding: utf-8 -*-
"""
Created on Tue Mar  1 08:28:01 2016

@author: HansG17
"""
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
import matplotlib.pyplot as plt
import cvxopt
import xlrd
from matplotlib import cm

#this is where we process the data from excel

wb=xlrd.open_workbook("collegedataxlsx")
sh = wb.sheet_by_index(0)

#http://www.tristanfletcher.co.uk/SVM%20Explained.pdf

class SVM:
    def __init__(self,X,y):
        self.X = X
        self.y = y

    def findParameters(self,X,y):
        # min 1/2 x^T P x + q^T x
        #Ax = b
        #y's are if the student is accepted -1 for being not accpeted 1 for being accpeted
        #put in cvxopt
        n_samples, n_features = X.shape
        #generate gram matrix (ie dot product matrix)
        K = self.gramMatrix(X)
        P = cvxopt.matrix(np.outer(y, y) * K)
        q = cvxopt.matrix(-1 * np.ones(n_samples))
        Gtry = cvxopt.matrix(np.diag(np.ones(n_samples) * -1))
        print(Gtry)
        htry = cvxopt.matrix(np.zeros(n_samples))


        A = cvxopt.matrix(y, (1, n_samples))
        print(y)
        print(A)
        b = cvxopt.matrix(0.0)
        #get SVM plain parameters from
        param = cvxopt.solvers.qp(P, q, Gtry, htry, A, b)
        array = param['x']
        return array

    # calculates plain based on vector generated by findParameters
    def WB_calculator(self,X,y):
        #calculates w vector
        yi = self.y
        X = np.asarray(X)
        y = np.asarray(y)
        important = self.findParameters(X,y)
        print("these are parameters")
        print(important)
        firstsum = [0 for x in range(0,len(y))]
        for point in range(0,len(important)):
            liste = X[point]*important[point]*yi[point]
            firstsum = [x + y for x, y in zip(firstsum,liste)]



        #this part calculates bias
            #this is a very naive implementation of bias
            #xstuff is the x_coordinate vector we find this by transpose
            #bunsen is SVM bias
            #bias is added to make the plain's hight divide the data as neatly as possible
            bunsen = 0
        for i in range(0,len(important)):
            bunsen = bunsen+ (yi[i]- np.dot(firstsum,X[i]))

        avgB = bunsen/len(important)
        answer = (firstsum , avgB)
        print("w vector")
        print(firstsum)
        return answer


     # kernal is a type of dot product#innerproduct
    def polynomialK(self,u,v,b):
        return (np.dot(u,v)+b)**2

 # gaussian kernal used to
    def gaussianK(self,v1, v2, sigma):
        return np.exp(-norm(v1-v2, 2)**2/(2.*sigma**2))

#computes the gramMatrix given a set of all points included in the data
#this is basicly a matrix of dot prodducts

    def gramMatrix(self,X):
        gramMatrix = []
        data = np.asarray(self.X)
        dataTran = data

        for x in dataTran:
            row = []

            for y in dataTran:

                row.append(np.dot(x,y))

            gramMatrix.append(row)

        return gramMatrix


        #  tells whether stduent is likely to be accpeted based on GPA and SAT and ACT
    def determineAcceptance(self,point,X,y):
        cutoff = self.WB_calculator(X,y)
        if(np.dot(cutoff[0],point)+cutoff[1] >0):
            #student did meet GPA and SAT requirements
            print("You got in")
        elif(np.dot(cutoff[0],point)+cutoff[1]<0):
            #students did not meet GPA and SAT requiremnets
            print("Study")




    # 2D graph for when for only GPA and SAT
     def TWDGraph(self,X,y):
        important_stuff = self.WB_calculator(X,y)
        weights = important_stuff[0]
        w1 = weights[0]
        w2 = weights[1]
        c = important_stuff[1]
        print(c)
        print(w2)
        figure2 = plt.figure();
        #setting up coordinates
        graphable = X.T
        xaxis = [x for x in graphable[0]]
        yaxis = [x for x in graphable[1]]
        print("done")
        #graph dividing line
        fig, ax = plt.subplots()
        ax.scatter(xaxis,yaxis)
        #X = np.arange(-2, 2,.1)
        x_min, x_max = [0,1]
        y_min, y_max = [(-c/w2) , ((-c/w2)+ (-w1/w2)*(x_max-x_min))]
        ax.plot([x_min, x_max], [y_min, y_max])
        ax.set_xlim([0,1])
        ax.set_ylim([0,1])
        plt.show()


    # plots  SVM plane based on W B paramateres
    #plots point repersenting students GPA and SAT
    def Graph(self,X,y):
        important_stuff = self.WB_calculator(X,y)
        weights = important_stuff[0]
        c = important_stuff[1]
        #here we actaually graph the functionb
        graphable = X.T
        fig = plt.figure()
        ax = fig.add_subplot(111, projection='3d')
        xs = graphable[0]
        ys = graphable[1]
        zs = graphable[2]

        colors = self.y
        ax.scatter(xs,ys,zs,c=colors)
        ax.set_xlabel("A")
        ax.set_ylabel("B")
        ax.set_zlabel("C")
        #this changes orientation and look of surface
        ax.view_init(azim = 180+160,elev = 0)
        X = np.arange(-1.2, 1.2, 0.25)
        Y = np.arange(-1.2, 1.2, 0.25)
        X, Y = np.meshgrid(X, Y)

        Z = ((-weights[0]*X + -weights[1]*Y - c)/(weights[2]))
        surf = ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=cm.coolwarm,
                       linewidth=0, antialiased=True)
        plt.show()


#list of points to train on
# a is input of SAT, GPA ,and ACT
a = [[.1,.1,.1],[.2,.2,.2],[.15,.15,.15],[.9,.9,.9],[.95,.95,.95]]
check = np.asarray(a)
#acceptance list
# -1 if not accepted 1 if accepted
b = [-1.0,-1,-1,1,1]
bigger =np.asarray(b)
d = SVM(a,b)
print(d.gramMatrix(check)[0])
print("parameters ya")
print(d.findParameters(check,bigger))
print(d.WB_calculator(check,bigger))
d.Graph(check,bigger)
#determines acceptance for prospective applicant
print(d.determineAcceptance([.01,.01,.01],check,bigger))
